<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title>Tech Talk - Git|Vim|RubyOnRails</title>
   <link href="http://tim.everyday-cn.com/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://tim.everyday-cn.com" rel="alternate" type="text/html" />
   <updated>2012-05-24T22:05:28+08:00</updated>
   <id>http://tim.everyday-cn.com</id>
   <author>
     <name>Tim.Tang</name>
     <email>tang.jilong@gmail.com</email>
   </author>

   
   <entry>
     <title>Rails3,GridFS,MongoID,CarrierWave实现图片上传</title>
     <link href="http://tim.everyday-cn.com/RubyOnRails/2012/05/24/rails3gridfsmongoidcarrierwave.html"/>
     <updated>2012-05-24T00:00:00+08:00</updated>
     <id>http://tim.everyday-cn.com/RubyOnRails/2012/05/24/rails3gridfsmongoidcarrierwave</id>
     <content type="html">&lt;p&gt;最近准备将Everyday CMS的数据存储由MySQL切换到MongoDB,作为实验先探探路，看看能不能用MongoDB的GridFS来存储图片，下面具体的实现：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先环境准备：Rails 3.1.3/Ruby 1.9.2p320/MongoDB 已经安装并启动，具体安装可参考&lt;a href=&quot;http://tim.everyday-cn.com/Ubuntu/2011/10/31/ubuntu11-10-mongodb.html&quot;&gt;UBUNTU11.10,MONGODB安装测试&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建app
&lt;pre&gt;
$ rails new demo
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改Gemfile文件，加入如下Gems
&lt;pre&gt;
gem 'mongoid' #2.4.10
gem 'bson_ext' #1.6.2
gem 'carrierwave' #0.5.8
gem 'carrierwave-mongoid', :require =&gt; 'carrierwave/mongoid' #0.1.7
gem 'mini_magick' #3.4
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生成mongoid.yml
&lt;pre&gt;
$ rails g mongoid:config
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过修改 config/application.rb去掉对默认数据库依赖
&lt;pre&gt;
# require 'rails/all'
require &quot;action_controller/railtie&quot;
require &quot;action_mailer/railtie&quot;
require &quot;active_resource/railtie&quot;
require &quot;rails/test_unit/railtie&quot;
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;继续添加以下代码，防止 error mongoid [not found] 的问题
&lt;pre&gt;
config.generators do |g|
g.orm :active_record
end
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;删除默认的 config/database.yml，并用scaffold创建blog应用:
&lt;pre&gt;
$ rm -f config/database.yml
$ rails g scaffold blog name:string content:text
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;添加carrierwave配置文件 config/initializers/carrierwave.rb
&lt;pre&gt;
CarrierWave.configure do |config|
config.storage = :grid_fs
config.grid_fs_access_url = &quot;&quot;
config.grid_fs_database = Mongoid.database.name
config.grid_fs_host = Mongoid.config.master.connection.host
end
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生成File Uploader
&lt;pre&gt;
$ rails g uploader File
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改app/uploaders/file_uploader.rb
&lt;pre&gt;
class FileUploader &amp;lt; CarrierWave::Uploader::Base
include CarrierWave::MiniMagick
# Choose what kind of storage to use for this uploader:
storage :grid_fs
# Override the directory where uploaded files will be stored.
def store_dir
 &quot;uploads/#{model.class.to_s.underscore}/#{mounted_as}/#{model.id}&quot;
end
def default_url
  &quot;/uploads/fallback/&quot; + [version_name, &quot;default.png&quot;].compact.join('_')
end
# Create different versions of your uploaded files:
version :thumb do
  process :resize_to_fill=&gt; [50, 50]
end
version :normal do
  process :resize_to_fill =&gt; [150, 200]
end
version :big do
  process :resize_to_fill =&gt; [250, 300]
end
version :large do
  process :resize_to_fill =&gt; [350, 400]
end
def extension_white_list
  %w(jpg jpeg gif png)
end
def filename
  &quot;something.jpg&quot; if original_filename
end
end
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生成生成gridfs的controller
&lt;pre&gt;
$ rails g controller gridfs
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改GridfsController,内容如下
&lt;pre&gt;
class GridfsController &amp;lt; ActionController::Metal
def serve
 gridfs_path = env[&quot;PATH_INFO&quot;].gsub(&quot;/uploads/&quot;, &quot;uploads/&quot;)
 begin
   puts &quot;---------------------------------------&quot;
   puts gridfs_path
   puts Mongoid.database.name
   puts &quot;---------------------------------------&quot;
   gridfs_file = Mongo::GridFileSystem.new(Mongoid.database).open(gridfs_path, 'r')
   self.response_body = gridfs_file.read
   self.content_type = gridfs_file.content_type
 rescue Exception =&gt; e
   self.status = :file_not_found
   Rails.logger.debug { &quot;#{e}&quot; }
   self.content_type = 'text/plain'
   self.response_body = ''
   raise e
 end
end
end
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改routes.rb，使开发模式下，通过gridfs这个controller来管理图片文件
&lt;pre&gt;
if Rails.env.development?
 match &quot;/uploads/*path&quot; =&gt; &quot;gridfs#serve&quot;
end
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改app/models/blog.rb，添加file字段，并挂载uploader, 注意这里不再继承active record.
&lt;pre&gt;
class Blog
include Mongoid::Document
  field :name
  field :content
  field :file
  mount_uploader :file, FileUploader
end
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改app/views/blogs/_form.html.erb，在content表单项下面添加图片上传
&lt;pre&gt;
&amp;lt;%= f.label :file %&gt;&lt;br /&gt;
&amp;lt;%= f.file_field :file %&gt;
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改 app/views/blogs/index.html.erb, 用来展现上传的图片
&lt;pre&gt;
&amp;lt;%= blog.file.size %&gt;
&amp;lt;%= blog.file.filename%&gt;
&amp;lt;%= image_tag blog.file_url(:thumb)%&gt;
&amp;lt;%= image_tag blog.file_url(:normal)%&gt;
&amp;lt;%= image_tag blog.file_url(:big)%&gt;
&amp;lt;%= image_tag blog.file_url(:large)%&gt;
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;到这里终于可以启动服务，上传图片了，看看结果
&lt;img src=&quot;http://tim.everyday-cn/images/post/carrierwave-mongoid.png&quot;/&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在看mongodb的查询结果，多了三个collection以及对于的储存记录
&lt;img src=&quot;http://tim.everyday-cn/images/post/mongodb-result.png&quot; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;blockquote&gt;&lt;p&gt;注意:尽量不要在rails3.1以下版本操作，否则会出现无法继承mongoid的问题，OK JSUT DO IT!&lt;/p&gt;&lt;/blockquote&gt;
</content>
   </entry>
   
   <entry>
     <title>XML,JSON转换存MongoDB</title>
     <link href="http://tim.everyday-cn.com/MongoDB/2012/05/22/xmljsonmongodb.html"/>
     <updated>2012-05-22T00:00:00+08:00</updated>
     <id>http://tim.everyday-cn.com/MongoDB/2012/05/22/xmljsonmongodb</id>
     <content type="html">&lt;p&gt;最近项目用到xml和json的转换，于是想到了如何用ruby来实现这个功能，下面介绍下如何实现：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安装XML转JSON需要的RubyGems
&lt;pre&gt;
$ gem install json
$ gem install crack
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装存储MongoDB所需要的RubyGems
&lt;pre&gt;
$ gem install mongo
$ gem install bson_ext
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;具体的代码实现
&lt;pre&gt;
#encoding:utf-8
require &quot;crack&quot;
require &quot;json&quot;
require &quot;mongo&quot;
myXML = Crack::XML.parse(File.read(&quot;/home/tim-tang/OFBProductCategory1.xml&quot;))
myJSON = myXML.to_hash
connection = Mongo::Connection.new(&quot;localhost&quot;, 27017)
db = connection.db(&quot;tim-db&quot;)
coll = db.collection(&quot;products&quot;)
coll.save(myJSON)
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对MongoDB的安装和使用有疑问的可以看&lt;a href=&quot;http://tim.everyday-cn.com/Ubuntu/2011/10/31/ubuntu11-10-mongodb.html&quot;&gt;Ubuntu11.10,MongoDB安装测试&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;blockquote&gt;&lt;p&gt;使用ruby现有的类库来操作XML&amp;amp;JSON，相对来说比java方便很多!&lt;/p&gt;&lt;/blockquote&gt;
</content>
   </entry>
   
   <entry>
     <title>Vim 实用命令</title>
     <link href="http://tim.everyday-cn.com/Vim/2012/05/18/vim-usefulcommands.html"/>
     <updated>2012-05-18T00:00:00+08:00</updated>
     <id>http://tim.everyday-cn.com/Vim/2012/05/18/vim-usefulcommands</id>
     <content type="html">&lt;h3&gt;光标移动&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;H：移动光标到屏幕上面&lt;/li&gt;
&lt;li&gt;M：移动光标到屏幕中间&lt;/li&gt;
&lt;li&gt;L：移动光标到屏幕下面&lt;/li&gt;
&lt;li&gt;fx：移动光标到当前行的下一个x处。很明显，x可以是任意一个字母，而且你可以使用;来重复你的上一个f命令。&lt;/li&gt;
&lt;li&gt;tx：和上面的命令类似，但是是移动到x的左边一个位置。（这真的很有用）&lt;/li&gt;
&lt;li&gt;Fx：和fx类似，不过是往回找。&lt;/li&gt;
&lt;li&gt;^ : 移到当前行的第一个非空字符。&lt;/li&gt;
&lt;li&gt;*：读取光标处的字符串，n 将光标移动到它再次出现的地方。&lt;/li&gt;
&lt;li&gt;0: 光标移动到行首&lt;/li&gt;
&lt;li&gt;V: 选中一行&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;视图模式下剪切和拷贝&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;d：剪贴选择的内容到剪贴板。&lt;/li&gt;
&lt;li&gt;y：拷贝选择的内容到剪贴板。&lt;/li&gt;
&lt;li&gt;c：剪贴选择的内容到剪贴板并且进入插入模式。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;代码处理&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;%：匹配花括号，方括号，括号等。在一个括号的上面，然后按%，鼠标就会出现在匹配的另外一半括号处。&lt;/li&gt;
&lt;li&gt;gf: 打开引用的文件。&lt;/li&gt;
&lt;li&gt;ctrl+o: 返回到原来的文件。&lt;/li&gt;
&lt;li&gt;ctrl+w, f: 打开引用的文件, 并split窗口给新文件。&lt;/li&gt;
&lt;li&gt;ctrl+w, q: 关闭窗口。&lt;/li&gt;
&lt;li&gt;gg=G   格式化全文代码&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;多列注释&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ctrl+v  选择列模式 输入I（大写），输入#或//，ctrl+[ 多列注释。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;Nerdtree插件&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;m: 提供文本文件系统菜单来创建/删除/移动/复制目录或文件&lt;/li&gt;
&lt;li&gt;r:  refreshing current directory&lt;/li&gt;
&lt;li&gt;R: refreshing root directory&lt;/li&gt;
&lt;li&gt;e: browser current directory&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;文件操作&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;:e ~/Desktop/xxx   打开文件&lt;/li&gt;
&lt;li&gt;:b#       返回到原来编辑的文件&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;文件查找&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;vimgrep /keywords/ &lt;em&gt;*/&lt;/em&gt;.rb&lt;/li&gt;
&lt;li&gt;:cw    打开查找结果&lt;/li&gt;
&lt;/ul&gt;


&lt;blockquote&gt;&lt;p&gt;vim的实用中还需要一些插件，具体的配置可以看我们的&lt;a href=&quot;https://github.com/tim-tang/vim&quot;&gt;&lt;strong&gt;vim环境&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;
</content>
   </entry>
   
   <entry>
     <title>Git,GitHub常用命令介绍</title>
     <link href="http://tim.everyday-cn.com/Git/2012/05/18/git.html"/>
     <updated>2012-05-18T00:00:00+08:00</updated>
     <id>http://tim.everyday-cn.com/Git/2012/05/18/git</id>
     <content type="html">&lt;h3&gt;Git给项目打标签&lt;/h3&gt;

&lt;pre&gt;
git tag -a v1.0 -m 'version 1.0'        #给项目打v1.0标签
git push --tags          #把标签推到github中
git tag checkout v1.0     #把项目检出到某个tag
git checkout master    #切换到master 分支
git tag -l                    #列出所有的tag
git tag -d v1.0            #删除某个tag
&lt;/pre&gt;


&lt;h3&gt;Git generate ssh key&amp;amp;add config params&lt;/h3&gt;

&lt;pre&gt;
ssh-keygen -t rsa -C &quot;tang.jilong@139.com&quot;
ssh -T git@github.com
git config --global user.name &quot;tim.tang&quot;
git config --global user.email &quot;tang.jilong@139.com&quot;

git config --global color.branch auto
git config --global color.diff auto
git config --global color.interactive auto
git config --global color.status auto

cat ~/.gitconfig
&lt;/pre&gt;


&lt;h3&gt;Git查看配置&lt;/h3&gt;

&lt;pre&gt;
git config -l             #查看所有配置
&lt;/pre&gt;


&lt;h3&gt;Git branch操作&lt;/h3&gt;

&lt;pre&gt;
git branch                 #查看分支
git branch -r              #查看远程分支
git branch -d tmp        #删除本地tmp分支
git branch everyday_dev  #在本地创建everyday_dev分支
git push origin everyday_dev  #把本地分支提交到github.
git push origin :everyday_dev   #删除github上的远程分支
&lt;/pre&gt;


&lt;h3&gt;Git diff操作&lt;/h3&gt;

&lt;pre&gt;
git diff [&lt;path&gt;...]  #这个命令最常用，在每次add进入index前会运行这个命令，查看即将add进入index时所做的内容修改，即working directory和index的差异。
git diff --cached [&lt;path&gt;...]   #这个命令初学者不太常用，却非常有用，它表示查看已经add进入index但是尚未commit的内容同最后一次commit时的内容的差异。即index和git directory的差异。
git diff &lt;commit&gt; &lt;commit&gt; [&lt;path&gt;...]   #这个命令用来比较git directory中任意两个&lt;commit&gt;之间的差别，如果想比较任意一个&lt;commit&gt;和最新版的差别，把其中一个&lt;commit&gt;换成HEAD即可
git diff --stat     #统计一下有哪些文件被改动，有多少行被改动
&lt;/pre&gt;


&lt;h3&gt;Git reset使用&lt;/h3&gt;

&lt;pre&gt;
git reset [--hard|soft|mixed|merge|keep] [&lt;commit&gt;或HEAD] #将当前的分支重设（reset）到指定的&lt;commit&gt;或者HEAD。
A). --hard：重设（reset） index和working directory，自从&lt;commit&gt;以来在working directory中的任何改变都被丢弃，并把HEAD指向&lt;commit&gt;。
B). --soft：index和working directory中的内容不作任何改变，仅仅把HEAD指向&lt;commit&gt;。这个模式的效果是，执行完毕后，自从&lt;commit&gt;以来的所有改变都会显示在git status的&quot;Changes to be committed&quot;中。
C). --mixed：仅reset index，但是不reset working directory。这个模式是默认模式，即当不显示告知git reset模式时，会使用mixed模式。这个模式的效果是，working directory中文件的修改都会被保留，不会丢弃，但是也不会被标记成&quot;Changes to be committed&quot;，但是会打出什么还未被更新的报告。
&lt;/pre&gt;


&lt;h3&gt;Git fetch&lt;/h3&gt;

&lt;pre&gt;
git fetch origin master:tmp
git diff master..tmp
git merge tmp
功能同上：
git fetch origin master
git log -p master..origin/master
git merge origin/master
&lt;/pre&gt;


&lt;h3&gt;Git blame&lt;/h3&gt;

&lt;pre&gt;
git blame filename    #查看当前文件每行代码的修改者
&lt;/pre&gt;


&lt;h3&gt;Git archive&lt;/h3&gt;

&lt;pre&gt;
git archive --format zip -o $(git log --pretty=format:&quot;%h&quot; -1).zip HEAD #打包代码
&lt;/pre&gt;

</content>
   </entry>
   
   <entry>
     <title>Ruby实现Mongo MapReduce初探</title>
     <link href="http://tim.everyday-cn.com/Ruby/2011/12/22/ruby-mongo-mapreduce.html"/>
     <updated>2011-12-22T00:00:00+08:00</updated>
     <id>http://tim.everyday-cn.com/Ruby/2011/12/22/ruby-mongo-mapreduce</id>
     <content type="html">&lt;p&gt;MapReduce是一种计算模型，简单的说就是将大批量的工作（数据）分解（MAP）执行，然后再将结果合并成最终结果（REDUCE）。这样做的好处是可以在任务被分解后，可以通过大量机器进行并行计算，减少整个操作的时间。下面以MongoDB MapReduce为例说明:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;计算一个标签系统中每个标签出现的次数通过ruby实现:&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;
require 'mongo'
class MongoMapReduce
    def generate_mr
        mongodb = init_mongo
        coll = mongodb.collection(&quot;things&quot;)
        map = &quot;function(){
            this.tags.forEach(
               function(z){
                    emit( z , { count : 1 } );
                }
            );
        };&quot;
        reduce = &quot;function( key , values ){
            var total = 0;
            for ( var i=0; i&lt;values.length; i++ )
                total += values[i].count;
            return { count : total };
        };&quot;
        m = BSON::Code.new(map)
        r = BSON::Code.new(reduce)
        output = coll.map_reduce(m, r, { :out =&gt; &quot;myresult&quot; })
        puts output.stats
        mongodb.collection(&quot;myresult&quot;).find().each{|row| puts row.inspect }
        output.drop
    end
    def init_mongo
        mongodb = Mongo::Connection.new(&quot;localhost&quot;, 27017).db(&quot;test&quot;)
        #coll = mongodb.collection(&quot;things&quot;)
        #init_data coll
    end
    def init_data coll
        doc = {&quot;_id&quot; =&gt;1,  &quot;tags&quot; =&gt; ['dog', 'cat']}
        doc2 = {&quot;_id&quot;=&gt;2, &quot;tags&quot; =&gt; ['cat']}
        doc3 = {&quot;_id&quot;=&gt;3, &quot;tags&quot; =&gt; ['mouse', 'cat', 'dog']}
        doc4 = {&quot;_id&quot;=&gt;4, &quot;tags&quot; =&gt; []}
        coll.insert(doc)
        coll.insert(doc2)
        coll.insert(doc3)
        coll.insert(doc4)
        coll.find().each {|row| puts row.inspect }
    end
end
MongoMapReduce.new.generate_mr
&lt;/pre&gt;


&lt;ul&gt;
&lt;li&gt;如需要运行以上代码还要安装mongo/bson/bson_ext:&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;
$ gem install mongo
$ gem install bson
$ gem install bson_ext
&lt;/pre&gt;


&lt;ul&gt;
&lt;li&gt;从上面的代码我们可以看出map/reduce是由符合js语法的函数组成，我们可以这样理解，当你在所有需要计算的行执行完了map函数，你就得到了一组key-values对。基本key是emit中的key，values是每次emit函数的第二个参数组成的集合。&lt;/li&gt;
&lt;li&gt;这里这个emit函数是非常重要的，他的作用是将一条数据放入数据分组集合。&lt;/li&gt;
&lt;li&gt;key-values变在key-value，也就是把这一个集合变成一个单一的值。这个操作就是Reduce&lt;/li&gt;
&lt;li&gt;我们必须了解这一机制会要求我们遵守的原则，那就是当我们书写Map函数时，emit的第二个参数形式是我们的Reduce函数的第二个参数，而Reduce函数的返回值，可能会作为新的输入参数再次执行Reduce操作，所以Reduce函数的返回值也需要和Reduce函数的第二个参数结构一致。&lt;/li&gt;
&lt;li&gt;当我们的key-values中的values集合过大，会被再切分成很多个小的key-values块，然后分别执行Reduce函数，再将多个块的结果组合成一个新的集合，作为Reduce函数的第二个参数，继续Reducer操作。可以预见，如果我们初始的values非常大，可能还会对第一次分块计算后组成的集合再次Reduce。&lt;/li&gt;
&lt;/ul&gt;


&lt;blockquote&gt;&lt;p&gt;具体的mongodb MapReduce内容可以参考&lt;a href=&quot;http://www.mongodb.org/display/DOCS/MapReduce#MapReduce-ShellExample2&quot; title=&quot;mapreduce&quot;&gt;&lt;strong&gt;&lt;em&gt;官方网站&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
</content>
   </entry>
   
   <entry>
     <title>Ruby 设计模式</title>
     <link href="http://tim.everyday-cn.com/Ruby/2011/12/15/ruby--3.html"/>
     <updated>2011-12-15T00:00:00+08:00</updated>
     <id>http://tim.everyday-cn.com/Ruby/2011/12/15/ruby--3</id>
     <content type="html">&lt;p&gt;昨天无意间翻了下&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;http://cms.everyday-cn.com/zh/ibook_download/13&quot; title=&quot;design pattern&quot;&gt;Design Patterns in Ruby&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;这本书，顺便复习了设计模式方面的东西，实现同样一个设计模式，无论在可扩展性还是代码的简洁程度都比java高出不少，下面看看如何用ruby实现常用的设计模式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Singleton Method:确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;
module SingletonClass
    class &lt;&lt; self
        def single
            puts &quot;This is singleton method!&quot;
        end
    end
end
SingletonClass.single
&lt;/pre&gt;


&lt;p&gt;可以看出使用ruby的Module来实现单例多么有优越性相比较java而言。
 - Chain of Responsibility Method:使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止&lt;/p&gt;

&lt;pre&gt;
class Chain
    def initialize
        @chain = []
    end
    def add_handler &amp;block
        @chain &lt;&lt; block
    end
    def handle req
        @chain.each do |e|
            # 如果handler返回 false(未处理)，则让下一个处理
            result = e[req]
            return result if result
        end
        false
    end
end
c = Chain.new
c.add_handler {|req| req == 1 ? &quot;1-handled&quot;: &quot;1-not my responsibility&quot; }
c.add_handler {|req| req == 2 ? &quot;2-handled&quot;: &quot;2-not my responsibility&quot; }
c.handle 1
c.handle 2
&lt;/pre&gt;


&lt;p&gt;利用了ruby提供的闭包的特性，动态处理代码块。
 - Proxy Method: 为某个对象提供代理对象:&lt;/p&gt;

&lt;pre&gt;
class Proxy
    def initialize origin
        @obj=origin
    end
    def method_missing (name, *args)
        @obj.send(name, *args)
    end
end
class Tool
  def execute args
      puts &quot;Executing tool methods now....#{args}&quot;
  end
end
proxy=Proxy.new(Tool.new)
proxy.execute &quot;xxxxxxx&quot;
&lt;/pre&gt;


&lt;p&gt;充分利用了ruby的元编程能力，运行时动态增加实例和方法，更强的扩展性。
 - Observer Method: 定义了对象间的一种一对多依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新&lt;/p&gt;

&lt;pre&gt;
class Employee
    attr_reader :name, :title
    attr_reader :salary
    def initialize( name, title, salary)
        @name = name
        @title = title
        @salary = salary
        @observers = []
    end
    def salary=(new_salary)
        @salary = new_salary
        notify_observers
    end
    def notify_observers
        @observers.each do |observer|
            observer.update(self)
        end
    end
    def add_observer(observer)
        @observers &lt;&lt; observer
    end
    def delete_observer(observer)
        @observers.delete(observer)
    end
end
class Payroll
    def update(changed_employee )
        puts(&quot;Cut a new check for #{changed_employee.name}!&quot;)
        puts(&quot;His salary is now #{changed_employee.salary}!&quot;)
    end
end
class TaxMan
    def update( changed_employee )
        puts(&quot;Send #{changed_employee.name} a new tax bill!&quot;)
    end
end
payroll = Payroll.new
tax_man = TaxMan.new
fred = Employee.new('Fred', 'Crane Operator', 30000)
fred.add_observer(payroll)
fred.salary = 35000
fred.add_observer(tax_man)
fred.salary = 88000
&lt;/pre&gt;


&lt;ul&gt;
&lt;li&gt;Builder Method: 将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;
class Director
    def build_with builder
        acc = ''
        [:header, :body, :footer].each do |m|
            acc += builder.send(m) if builder.respond_to? m
        end
        acc
    end
end
class HTMLBuilder
    def header; '&lt;html&gt;&lt;title&gt;html builder&lt;/title&gt;';end
    def body;     '&lt;body&gt;html builder&lt;/body&gt;'        ;end
    def footer; '&lt;/html&gt;'                          ;end
end
class XMLBuilder
    def header; '&lt;?xml version=&quot;1.0&quot; charset=&quot;utf-8&quot;&gt;';end
    def body;   '&lt;root&gt;xml builder&lt;/root&gt;'            ;end
end
d = Director.new
puts(d.build_with HTMLBuilder.new)
puts(d.build_with XMLBuilder.new)
&lt;/pre&gt;


&lt;p&gt;还是通过ruby元编程利用send动态执行方法&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;通过上上面的这些设计模式，可以看出没有类型声明和继承，代码耦合降低，接口也无用武之地了。当我们回头再出用JAVA来实现这些设计模式的话，会是什么情况？&lt;/p&gt;&lt;/blockquote&gt;
</content>
   </entry>
   
   <entry>
     <title>Ruby DSL初探</title>
     <link href="http://tim.everyday-cn.com/Ruby/2011/12/13/ruby-dsl.html"/>
     <updated>2011-12-13T00:00:00+08:00</updated>
     <id>http://tim.everyday-cn.com/Ruby/2011/12/13/ruby-dsl</id>
     <content type="html">&lt;p&gt;Ruby 是当前用于建立内部 DSL 最流行的语言。当在 Ruby 上开发时你所考虑的大部分基础设施都是基于 DSL 的例如：Active Record、RSpec、Cucumber、Rake 以及许多其他方面，— 因为它是服从于主机托管内部 DSL 的。行为驱动开发 (BDD) 的新潮技术需要一个强大的 DSL 基础来实现其普及。Rails DSL很大程度上依赖于Ruby的元编程能力，这里将对Ruby的 DSL 写一个简单测试的例子，功能如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;向baidu发送搜索请求&lt;/li&gt;
&lt;li&gt;关键字是everyday-cn&lt;/li&gt;
&lt;li&gt;查找搜索结果中有没有我要检查的关键字&lt;/li&gt;
&lt;/ul&gt;


&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;首先给出测试脚本,新建test.txt文件：&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;
host &quot;www.baidu.com&quot;
port 80
page &quot;s&quot;
field &quot;wd&quot;,&quot;everyday-cn&quot;
field &quot;sourceid&quot;,&quot;Mozilla-search&quot;
get
check_content &quot;tang.jilong&quot;
check_content &quot;Tim.Tang&quot;
&lt;/pre&gt;


&lt;ul&gt;
&lt;li&gt;编写ruby dsl文件：&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;
require 'open-uri'
class MyDSL
    def self.dsl_accessor(*symbols)
        symbols.each { |sym|
            class_eval %{
                def #{sym}(*val)
                  if val.empty?
                   @#{sym}
                  else
                   @#{sym} = val.size == 1 ? val[0] : val
                  end
                end
            }
        }
    end
    def method_missing(sym, *args)
        self.class.dsl_accessor sym
        puts &quot;method missing #{sym}, #{args}&quot;
        send(sym, *args)
    end
    attr_accessor :query
    dsl_accessor :test
    def self.load(filename)
        dsl = new
        dsl.instance_eval(File.read(filename), filename)
        puts File.read(filename)
        dsl
    end
    def self.loads(filename)
        dsl = new
        dsl.instance_eval(filename)
        dsl
    end
    def field(field_string,value)
        puts &quot;#{field_string}=#{value}&quot;
        if ! @query
            @query=&quot;#{field_string}=#{value}&quot;
        else
            @query=&quot;#{@query}&amp;#{field_string}=#{value}&quot;
        end
        puts @query
    end
    def get
        puts 'get'
        @request=&quot;http://#{@host}:#{@port}/#{@page}?#{@query}&quot;
        puts @request
        @result=open(@request)
    end
    def check_content(s)
        tmp=@result.read.scan(s).uniq
        if tmp.length!=0
            puts &quot;found&quot;
            puts tmp
        else
            puts &quot;not found&quot;
        end
    end
    def post
        puts 'post'
    end
end
dsl=MyDSL.load(&quot;dsl.txt&quot;)
p dsl
p dsl.instance_variables
&lt;/pre&gt;


&lt;ul&gt;
&lt;li&gt;其中method_missing和dsl_accessor让客户端动态增删属性的功能&lt;/li&gt;
&lt;/ul&gt;


&lt;blockquote&gt;&lt;p&gt;目前ruby dsl还主要用在测试领域，将来的发展潜力巨大。&lt;/p&gt;&lt;/blockquote&gt;
</content>
   </entry>
   
   <entry>
     <title>Ruby使用rexml解析xml</title>
     <link href="http://tim.everyday-cn.com/Ruby/2011/12/12/ruby-rexml-xml.html"/>
     <updated>2011-12-12T00:00:00+08:00</updated>
     <id>http://tim.everyday-cn.com/Ruby/2011/12/12/ruby-rexml-xml</id>
     <content type="html">&lt;p&gt;在开发中常用到xml解析，在ruby中我们可以使用rexml来解析xml,rexml具有如下特点:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;100%用ruby编写&lt;/li&gt;
&lt;li&gt;可以用来解析SAX和DOM&lt;/li&gt;
&lt;li&gt;轻量，不足2000行代码&lt;/li&gt;
&lt;li&gt;提供完整的API支持&lt;/li&gt;
&lt;li&gt;ruby中内置&lt;/li&gt;
&lt;/ul&gt;


&lt;hr /&gt;

&lt;p&gt;下面我们来看看如何使用它：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;假设我们有如下xml文件：&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;
&lt;collection shelf=&quot;New Arrivals&quot;&gt;
    &lt;movie title=&quot;Enemy Behind&quot;&gt;
        &lt;type&gt;War, Thriller&lt;/type&gt;
        &lt;format&gt;DVD&lt;/format&gt;
        &lt;year&gt;2003&lt;/year&gt;
        &lt;rating&gt;PG&lt;/rating&gt;
        &lt;stars&gt;10&lt;/stars&gt;
        &lt;description&gt;Talk about a US-Japan war&lt;/description&gt;
    &lt;/movie&gt;
    &lt;movie title=&quot;Transformers&quot;&gt;
        &lt;type&gt;Anime, Science Fiction&lt;/type&gt;
        &lt;format&gt;DVD&lt;/format&gt;
        &lt;year&gt;1989&lt;/year&gt;
        &lt;rating&gt;R&lt;/rating&gt;
        &lt;stars&gt;8&lt;/stars&gt;
        &lt;description&gt;A schientific fiction&lt;/description&gt;
    &lt;/movie&gt;
    &lt;movie title=&quot;Trigun&quot;&gt;
        &lt;type&gt;Anime, Action&lt;/type&gt;
        &lt;format&gt;DVD&lt;/format&gt;
        &lt;episodes&gt;4&lt;/episodes&gt;
        &lt;rating&gt;PG&lt;/rating&gt;
        &lt;stars&gt;10&lt;/stars&gt;
        &lt;description&gt;Vash the Stampede!&lt;/description&gt;
    &lt;/movie&gt;
    &lt;movie title=&quot;Ishtar&quot;&gt;
        &lt;type&gt;Comedy&lt;/type&gt;
        &lt;format&gt;VHS&lt;/format&gt;
        &lt;rating&gt;PG&lt;/rating&gt;
        &lt;stars&gt;2&lt;/stars&gt;
        &lt;description&gt;Viewable boredom&lt;/description&gt;
    &lt;/movie&gt;
&lt;/collection&gt;
&lt;/pre&gt;


&lt;ul&gt;
&lt;li&gt;解析DOM：&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;
require 'rexml/document'
include REXML
xmlfile = File.new(&quot;movies.xml&quot;)
xmldoc = Document.new(xmlfile)
root = xmldoc.root
puts &quot;Root element : &quot; + root.attributes[&quot;shelf&quot;]
xmldoc.elements.each(&quot;collection/movie&quot;){
    |e| puts &quot;Movie Title : &quot; + e.attributes[&quot;title&quot;]
}
xmldoc.elements.each(&quot;collection/movie/type&quot;) {
    |e| puts &quot;Movie Type : &quot; + e.text
}
xmldoc.elements.each(&quot;collection/movie/description&quot;) {
    |e| puts &quot;Movie Description : &quot; + e.text
}
&lt;/pre&gt;


&lt;ul&gt;
&lt;li&gt;使用XPATH：&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;
require 'rexml/document'
include REXML
xmlfile = File.new(&quot;movies.xml&quot;)
xmldoc = Document.new(xmlfile)
movie = XPath.first(xmldoc, &quot;//movie&quot;)
p movie
XPath.each(xmldoc, &quot;//type&quot;) { |e| puts e.text }
names = XPath.match(xmldoc, &quot;//format&quot;).map {|x| x.text }
p names
&lt;/pre&gt;


&lt;blockquote&gt;&lt;p&gt;以备不时之需&lt;/p&gt;&lt;/blockquote&gt;
</content>
   </entry>
   
   <entry>
     <title>Ruby使用DBI gem操作mysql</title>
     <link href="http://tim.everyday-cn.com/Ruby/2011/12/12/ruby-dbi-gem-mysql.html"/>
     <updated>2011-12-12T00:00:00+08:00</updated>
     <id>http://tim.everyday-cn.com/Ruby/2011/12/12/ruby-dbi-gem-mysql</id>
     <content type="html">&lt;p&gt;之前使用rails开发，处理数据库操作这方面都是使用active record, 它是一个orm的框架，一直在找一个更加轻量的gem，于是找到了dbi，它包括数据库接口（具有跨平台性）和数据库驱动（数据库独立），下面介绍如何使用它：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;安装dbi,dbd-mysql&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;
gem install dbi
gem install dbd-mysql
&lt;/pre&gt;


&lt;ul&gt;
&lt;li&gt;如果发现上面的命令安装不了，我们可以去rubygems.org下载以后手动安装&lt;/li&gt;
&lt;li&gt;下面给出具体使用的代码：&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;
require 'dbi'
begin
    dbh = DBI.connect('DBI:Mysql:crawler_engine', 'root', 'root')
    dbh['AutoCommit'] = false # Set auto commit to false.
    sql = &quot;insert into sources(site_name, link, filter, category) VALUES (?,?,?,?)&quot;
    dbh.prepare(sql) do | sth |
        1.upto(13) { |i| sth.execute(&quot;tim #{i}&quot;, &quot;link#{i*10}&quot;, &quot;filter#{i*100}&quot;, &quot;cat#{i*100}&quot;)}
    end
    dbh.select_all('select * from sources') do | row |
        p row
    end
    usql=&quot;update sources set filter=? where id &gt; ?&quot;
    dbh.prepare(usql) do |stmt|
        stmt.execute(&quot;xxxxxxxxxxxx&quot;, 10)
    end
    dbh.select_all(&quot;select * from sources where id&gt;10&quot;) do |row|
        p row
    end
    dbh.do('delete from sources where id &gt; 10')
    dbh.commit
rescue DBI::DatabaseError =&gt; e
        puts &quot;Error: #{e}&quot;
        dbh.rollback
ensure
        dbh.disconnect if dbh
end
&lt;/pre&gt;


&lt;blockquote&gt;&lt;p&gt;就写到这里，方便查阅。&lt;/p&gt;&lt;/blockquote&gt;
</content>
   </entry>
   
   <entry>
     <title>Mac安装配置oh my zsh</title>
     <link href="http://tim.everyday-cn.com/Mac/2011/12/09/mac-oh-my-zsh.html"/>
     <updated>2011-12-09T00:00:00+08:00</updated>
     <id>http://tim.everyday-cn.com/Mac/2011/12/09/mac-oh-my-zsh</id>
     <content type="html">&lt;p&gt;最近看了一些 ruby-china上的帖子，有人介绍说mac terminal下可以使用zsh(zsh是bash的一个扩展,并且兼容bash命令).但需要安装一些东西，mac默认使用的是bash shell。在mac 下有oh my zsh的东东介绍说不错，提供了很多的主题和rails/git/gem等的插件最重要的是提供了自动补全的功能，下面记录下具体的安装和配置：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;安装oh my zsh:&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;
wget --no-check-certificate https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh
&lt;/pre&gt;


&lt;ul&gt;
&lt;li&gt;要让安装生效，只要重启终端即可&lt;/li&gt;
&lt;li&gt;我们可以看到在~/目录下生成了.zshrc文件，修改它让它支持rvm,方便rails开发，将原来.bash_profile与.profile中的自定义内容导入过来：&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;
...
[[ -s &quot;$HOME/.rvm/scripts/rvm&quot; ]] &amp;&amp; . &quot;$HOME/.rvm/scripts/rvm&quot;
...
&lt;/pre&gt;


&lt;ul&gt;
&lt;li&gt;到这里我们就可以增加rails3开发要使用到的插件了,继续修改~/.zshrc文件：&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;
 # Example format: plugins=(rails git textmate ruby lighthouse)
plugins=(rails3 rails git textmate ruby rvm gem github brew bundler textmate pow osx)
&lt;/pre&gt;


&lt;ul&gt;
&lt;li&gt;继续修改主题,个人比较喜欢的是candy和darkblood,更多主题可以看它的github wiki：&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;
...
ZSH_THEME=&quot;darkblood&quot;
...
&lt;/pre&gt;


&lt;ul&gt;
&lt;li&gt;使~/.zshrc文件生效：&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;
source ~/.zshrc
&lt;/pre&gt;


&lt;ul&gt;
&lt;li&gt;这样我们就可以看到效果了，如图：
&lt;img src=&quot;http://cms.everyday-cn.com/system/pictures/1195/large_oh-my-zsh.png?1323394528&quot; title=&quot;oh my zsh&quot; alt=&quot;oh-my-zsh&quot; /&gt;&lt;/li&gt;
&lt;li&gt;我们还可以查看所有oh my zsh提供的自动补全：&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;
$ grep -h -r -e '^alias' ~/.oh-my-zsh
&lt;/pre&gt;


&lt;blockquote&gt;&lt;p&gt;就写到这里，更多资料可以看这里&lt;a href=&quot;https://github.com/robbyrussell/oh-my-zsh&quot; title=&quot;oh my zsh&quot;&gt;oh-my-zsh&lt;/a&gt;  原创文章&lt;/p&gt;&lt;/blockquote&gt;
</content>
   </entry>
   
 
</feed>