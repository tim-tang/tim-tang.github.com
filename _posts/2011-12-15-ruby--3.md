---
layout: post
title: Ruby 设计模式
description: Ruby 设计模式
key: []
---
昨天无意间翻了下***[Design Patterns in Ruby][1]***这本书，顺便复习了设计模式方面的东西，实现同样一个设计模式，无论在可扩展性还是代码的简洁程度都比java高出不少，下面看看如何用ruby实现常用的设计模式：

 - Singleton Method:确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例
<pre>
module SingletonClass
	class << self
		def single
			puts "This is singleton method!"
		end
	end
end
SingletonClass.single
</pre>
可以看出使用ruby的Module来实现单例多么有优越性相比较java而言。
 - Chain of Responsibility Method:使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止
<pre>
class Chain
	def initialize
		@chain = []
	end
	def add_handler &block
		@chain << block
	end
	def handle req
		@chain.each do |e|
			# 如果handler返回 false(未处理)，则让下一个处理
			result = e[req]
			return result if result
		end
		false
	end
end
c = Chain.new
c.add_handler {|req| req == 1 ? "1-handled": "1-not my responsibility" }
c.add_handler {|req| req == 2 ? "2-handled": "2-not my responsibility" }
c.handle 1
c.handle 2
</pre>
利用了ruby提供的闭包的特性，动态处理代码块。
 - Proxy Method: 为某个对象提供代理对象:
<pre>
class Proxy
	def initialize origin
		@obj=origin
	end
	def method_missing (name, *args)
		@obj.send(name, *args)
	end
end
class Tool
  def execute args
	  puts "Executing tool methods now....#{args}"
  end
end
proxy=Proxy.new(Tool.new)
proxy.execute "xxxxxxx"
</pre>
充分利用了ruby的元编程能力，运行时动态增加实例和方法，更强的扩展性。
 - Observer Method: 定义了对象间的一种一对多依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新
<pre>
class Employee
	attr_reader :name, :title
	attr_reader :salary
	def initialize( name, title, salary)
		@name = name
		@title = title
		@salary = salary
		@observers = []
	end
	def salary=(new_salary)
		@salary = new_salary
		notify_observers
	end
	def notify_observers
		@observers.each do |observer|
			observer.update(self)
		end
	end
	def add_observer(observer)
		@observers << observer
	end
	def delete_observer(observer)
		@observers.delete(observer)
	end
end
class Payroll
	def update(changed_employee )
		puts("Cut a new check for #{changed_employee.name}!")
		puts("His salary is now #{changed_employee.salary}!")
	end
end
class TaxMan
	def update( changed_employee )
		puts("Send #{changed_employee.name} a new tax bill!")
	end
end
payroll = Payroll.new
tax_man = TaxMan.new
fred = Employee.new('Fred', 'Crane Operator', 30000)
fred.add_observer(payroll)
fred.salary = 35000
fred.add_observer(tax_man)
fred.salary = 88000
</pre>
 - Builder Method: 将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示
<pre>
class Director
	def build_with builder
		acc = ''
		[:header, :body, :footer].each do |m|
			acc += builder.send(m) if builder.respond_to? m
		end
		acc
	end
end
class HTMLBuilder
	def header; '<html><title>html builder</title>';end
	def body;	  '<body>html builder</body>'        ;end
	def footer; '</html>'                          ;end
end
class XMLBuilder
	def header; '<?xml version="1.0" charset="utf-8">';end
	def body;   '<root>xml builder</root>'            ;end
end
d = Director.new
puts(d.build_with HTMLBuilder.new)
puts(d.build_with XMLBuilder.new)
</pre>
还是通过ruby元编程利用send动态执行方法

> 通过上上面的这些设计模式，可以看出没有类型声明和继承，代码耦合降低，接口也无用武之地了。当我们回头再出用JAVA来实现这些设计模式的话，会是什么情况？

  [1]: http://www.everyday-cn.com/zh/ibook_download/13 "design pattern"
